#!/bin/sh

CURRENT=$(git symbolic-ref -q HEAD || git rev-parse HEAD)
CURRENT=${CURRENT#refs/heads/}

this=$(basename "$0")

# default settings
explain=false
verbose=true
run=true

# colors
RED="\033[0;31m"
YELLOW="\033[1;33m"
GREEN="\033[0;32m"
NO_COLOR="\033[0m"

die() {
  echo "${RED}${@}${NO_COLOR}"
  exit 1
}

warn() {
  echo "${YELLOW}${@}${NO_COLOR}"
}

good() {
  echo "${GREEN}${@}${NO_COLOR}"
}

#git stuff
GIT=`which git`

git() {
  if [[ "$verbose" == true ]]; then
    echo "+ ${GREEN}git $@${NO_COLOR}"
  fi

  if [[ "$run" == true ]]; then
    eval "$GIT $@"
  fi
}

no_changes () {
  $GIT diff-index --quiet --cached HEAD -- &&
  $GIT diff-files --quiet
}

check_stash() {
  if [[ "$stashed" == true ]]; then
    warn "Your stashed changes were not applied because an error occurred. Don't panic. They are not lost. Look for them in \"git stash list\"."
  fi
}

is_integer() {
  [ "$1" -eq "$1" ] > /dev/null 2>&1
  return $?
}

printShortUsage() {
  echo "Usage: $this [<options>] push [<change number>]"
  echo "   or: $this [<options>] <change number>"
  echo "   or: $this [<options>] reset"
}
printUsage() {
  printShortUsage
  echo
  echo "OPTIONS"
  echo "  -h  --help                  Show this message"
  echo "  -v  --verbose               Show all commands before running them (default: on)"
  echo "  -q  --quiet                 Don't display commands before running them (default: off)"
  echo "  -e  --explain  --dry-run    Don't actually run commands (default: off)"
  echo
  echo "DESCRIPTION"
  echo "  $this assists in code reviews with gerrit, both pushing or pulling changesets to review."
  echo
  echo "  push [<change number>]"
  echo "    Pushes a single patch to gerrit for review. If your HEAD is master, $this will"
  echo "    reset master to origin/master after successfully pushing the changeset. If you are"
  echo "    working on a topic branch, that branch will be left alone."
  echo
  echo "    Given a change number, the current patch will replace the existing one, following"
  echo "    the same reset rules as above."
  echo
  echo "  <change number>"
  echo "    Applies the latest patch for the change at <change number> on top of master on a"
  echo "    branch named for <change number>, allowing you to review the change."
  echo
  echo "  reset"
  echo "    Removes the current change branch created by the 'start' subcommand and switches"
  echo "    back to master."
  echo
  echo "  diff <change number> [<patch number> <patch number>]"
  echo "    Displays a diff of the last two patches applies to the given changeset, or between"
  echo "    the given patches of that changeset."
}


pushReview() {
  change=$1
  if [[ -z "$change" ]]; then
    # try to read the change number from the branch name
    if [[ "${CURRENT:0:1}" == "r" ]]; then
      change=${CURRENT:1}
      if is_integer $change; then
        good "Using change number $change from branch name"
      else
        change=""
      fi
    fi
  fi

  LOG=$($GIT log --pretty="format:%s" origin/master..HEAD)
  CHANGESETS=$($GIT rev-list origin/master..HEAD | wc -l)
  CHANGESETS=${CHANGESETS//[[:space:]]}

  if [[ "$CHANGESETS" == "0" ]]; then
    die "You have no changes to review. Are you on the right branch?"
  elif [[ "$CHANGESETS" != "1" ]]; then
    die "You have $CHANGESETS changes, but you should only push one at a time. Did you forget to squash your commits?"
  fi

  if [[ "$change" != "" ]]; then
    change_args="origin HEAD:refs/changes/$change"
  fi

  git push $change_args ||
    die "Could not push your changes for review. Perhaps you need to update first?"

  if [[ "$CURRENT" == "master" ]]; then
    git reset --hard origin/master ||
      die "Could not reset your master branch to origin/master."
  fi

  if [[ "$run" == true ]]; then
    if [[ "$CURRENT" == "master" ]]; then
      good "Successfully pushed '$LOG' for review and reset master"
    else
      good "Successfully pushed '$LOG' for review"
    fi
  fi
}

# git review 100
startReview() {
  $GIT remote show changes 2>/dev/null 1>&2 ||
    die "In order to use $this to start a review, you need a 'changes' remote. Please add it before trying again."

  # pick up the latest patch for the changeset we're reviewing
  git fetch changes ||
    die "Unable to fetch changes, please check your network connection"

  change=$1
  changeref=refs/remotes/changes/${change:(-2)}/$change
  patchref=$($GIT rev-parse --symbolic-full-name --all | grep $changeref | sort --reverse | head -n1)

  if [[ -z "$patchref" ]]; then
    die "Unable to find a patch for ±$change"
  fi

  # create a new branch based on master to work in
  branch=r$change
  $GIT branch -D $branch 2>/dev/null 1>&2
  git checkout -b $branch master ||
    die "Unable to create a new branch '$branch'"

  # apply the change to the new branch
  git cherry-pick $patchref ||
    die "Unable to apply ±$change on top of master"

  if [[ "$run" == true ]]; then
    good "Successfully cherry-picked ±$change so you can begin reviewing it"
  fi
}


# git review reset
resetReview() {
  if [[ ! -z "$@" ]]; then
    warn "$this: unrecognized argument $1 for 'reset' subcommand"
    printUsage
    exit 2
  fi

  git checkout master && git branch -D $CURRENT ||
    die "Unable to close the review branch $CURRENT"
}

diffPatches() {
  change=$1
  if [ "$change" == "" ]; then
    die "You must specify a changeset (and optionally, patch numbers) to diff"
  fi

  patch1=$2
  patch2=$3
  changeref=refs/remotes/changes/${change:(-2)}/$change

  if [ "$patch1" != "" ] && [ "$patch2" != "" ]; then
    patchref1=$changeref/$patch1
    patchref2=$changeref/$patch2
  else
    patchref1=$($GIT rev-parse --symbolic-full-name --all | grep $changeref | sort --reverse | head -n2 | tail -n1)
    patchref2=$($GIT rev-parse --symbolic-full-name --all | grep $changeref | sort --reverse | head -n1)
    if [ "$patchref1" == "$patchref2" ]; then
      die "Only one patchset--nothing to diff!"
    fi
  fi

  $GIT diff --src-prefix=$patchref1: --dst-prefix=$patchref2: $patchref1 $patchref2
}

if ! no_changes; then
  die "You have local changes. Please do something with them before using $this"
fi

$GIT svn info >/dev/null 2>/dev/null &&
  die "$this does not support git-svn repositories."

while true; do
  arg=$1
  shift
  test -z "$arg" && break;

  case $arg
  in
    -e | --explain | --dry-run)
      echo "$this: using explain-only mode"
      explain=true
      verbose=true
      run=false
      ;;
    -v | --verbose)
      verbose=true
      ;;
    -q | --quiet)
      verbose=false
      ;;
    -h | --help)
      printUsage
      exit
      ;;
    start)
      startReview $1
      exit
      ;;
    reset)
      resetReview $@
      exit
      ;;
    push)
      pushReview $1
      exit
      ;;
    diff)
      diffPatches $1 $2 $3
      exit
      ;;
    *)
      if is_integer $arg; then
        startReview $arg
        exit
      else
        warn "$this: unrecognized option or subcommand $arg"
        printUsage
        exit 2
      fi
      ;;
  esac
done

# no subcommand given
printShortUsage
exit 2
