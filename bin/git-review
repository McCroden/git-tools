#!/bin/bash

CURRENT=$(git symbolic-ref -q HEAD || git rev-parse HEAD)
CURRENT=${CURRENT#refs/heads/}

this=$(basename "$0")

# default settings
explain=false
verbose=true
run=true

# colors
RED="\033[0;31m"
YELLOW="\033[1;33m"
GREEN="\033[0;32m"
NO_COLOR="\033[0m"

die() {
  echo -e "${RED}${@}${NO_COLOR}"
  exit 1
}

warn() {
  echo -e "${YELLOW}${@}${NO_COLOR}"
}

good() {
  echo -e "${GREEN}${@}${NO_COLOR}"
}

#git stuff
GIT=`which git`

git() {
  if [ "$verbose" = true ]; then
    echo -e "+ ${GREEN}git $@${NO_COLOR}"
  fi

  if [ "$run" = true ]; then
    eval "git_output=\$($GIT $@ 2>&1 | tee /dev/tty)"
  fi
}

no_changes () {
  $GIT diff-index --quiet --cached HEAD -- &&
  $GIT diff-files --quiet
}

check_stash() {
  if [ "$stashed" = true ]; then
    warn "Your stashed changes were not applied because an error occurred. Don't panic. They are not lost. Look for them in \"git stash list\"."
  fi
}

is_integer() {
  [ "$1" -eq "$1" ] > /dev/null 2>&1
  return $?
}

is_review_branch() {
  local branch=$1
  if [ "${branch:0:1}" = "r" ]; then
    local change=${branch:1}
    if is_integer $change; then
      return 0
    fi
  fi
  return 1
}

printShortUsage() {
  echo "Usage: $this [<options>] push [<change number>]"
  echo "   or: $this [<options>] <change number>"
  echo "   or: $this [<options>] reset"
}
printUsage() {
  printShortUsage
  echo
  echo "OPTIONS"
  echo "  -h  --help                  Show this message"
  echo "  -v  --verbose               Show all commands before running them (default: on)"
  echo "  -q  --quiet                 Don't display commands before running them (default: off)"
  echo "  -e  --explain  --dry-run    Don't actually run commands (default: off)"
  echo
  echo "DESCRIPTION"
  echo "  $this assists in code reviews with gerrit, both pushing or pulling changesets to review."
  echo
  echo "  push [<change number>]"
  echo "    Pushes a single patch to gerrit for review. If your HEAD is master, $this will"
  echo "    reset master to origin/master after successfully pushing the changeset. If you are"
  echo "    working on a topic branch, that branch will be left alone."
  echo
  echo "    Given a change number, the current patch will replace the existing one, following"
  echo "    the same reset rules as above."
  echo
  echo "  <change number>"
  echo "    Applies the latest patch for the change at <change number> on top of master on a"
  echo "    branch named for <change number>, allowing you to review the change."
  echo
  echo "  update"
  echo "    Updates the review branch that you're currently on to the latest patch."
  echo
  echo "  reset"
  echo "    Removes the current change branch created by the 'start' subcommand and switches"
  echo "    back to master."
  echo
  echo "  diff <change number> [<patch number> <patch number>]"
  echo "    Displays a diff of the last two patches applies to the given changeset, or between"
  echo "    the given patches of that changeset."
  echo
  echo "  rebase [<change number>]"
  echo "    Rebases the latest patch for a given change number (or the current change branch)"
  echo "    against master, then submits it as a new patch to that change. This helps deal with"
  echo "    Gerrit's \"Your change could not be merged due to a path conflict\" error message."
}


pushReview() {
  abort_on_bad_repo_state

  local change=$1
  if [ -z "$change" ]; then
    # try to read the change number from the branch name
    if is_review_branch $CURRENT; then
      local change=${CURRENT:1}
      if [ $run = true ]; then
        good "Using change number $change from branch name"
      fi
    fi
  fi

  local LOG=$($GIT log --pretty="format:%s" origin/master..HEAD)
  local CHANGESETS=$($GIT rev-list origin/master..HEAD | wc -l)
  local CHANGESETS=${CHANGESETS//[[:space:]]}

  if [ "$run" = true ]; then
    if [ "$CHANGESETS" = "0" ]; then
      die "You have no changes to review. Are you on the right branch?"
    elif [ "$CHANGESETS" != "1" ]; then
      die "You have $CHANGESETS changes, but you should only push one at a time. Did you forget to squash your commits?"
    fi
  fi

  if [ "$change" != "" ]; then
    local change_args="origin HEAD:refs/changes/$change"
  fi

  git push $change_args ||
    die "Could not push your changes for review. Perhaps you need to update first?"

  git_push_output="$git_output"

  if [ "$CURRENT" = "master" ]; then
    git reset --hard origin/master ||
      die "Could not reset your master branch to origin/master."
  fi

  if [ "$run" = true ]; then
    url=$(echo "$git_push_output" | grep http | head -n1)

    if [[ ! -z "$BROWSER" && ! -z "$url" ]]; then
      eval "$BROWSER $url"
    fi

    if [ "$CURRENT" = "master" ]; then
      good "Successfully pushed '$LOG' for review and reset master"
    else
      good "Successfully pushed '$LOG' for review"
    fi
  fi
}

# git review 100
startReview() {
  abort_on_bad_repo_state

  $GIT remote show changes 2>/dev/null 1>&2 ||
    die "In order to use $this to start a review, you need a 'changes' remote. Please add it before trying again."

  # pick up the latest patch for the changeset we're reviewing
  git fetch changes ||
    die "Unable to fetch changes, please check your network connection"

  local change=$1
  local changeref=refs/remotes/changes/${change:(-2)}/$change
  local patchref=$($GIT rev-parse --symbolic-full-name --all | grep $changeref | \
    awk -F'/' 'BEGIN{ maxpn = 0; maxref = "" } { pn = $NF; if (pn > maxpn) { maxpn = pn; maxref = $0 } } END{ print maxref }')

  if [ -z "$patchref" ]; then
    die "Unable to find a patch for ±$change"
  fi

  # create a new branch based on master to work in
  local branch=r$change
  $GIT branch -D $branch 2>/dev/null 1>&2
  git checkout -b $branch master ||
    die "Unable to create a new branch '$branch'"

  # apply the change to the new branch
  git cherry-pick $patchref ||
    die "Unable to apply ±$change on top of master"

  if [ "$run" = true ]; then
    good "Successfully cherry-picked ±$change so you can begin reviewing it"
  fi
}


# git review reset
resetReview() {
  abort_on_bad_repo_state

  if [ ! -z "$@" ]; then
    warn "$this: unrecognized argument $1 for 'reset' subcommand"
    printUsage
    exit 2
  fi

  git checkout master && git branch -D $CURRENT ||
    die "Unable to close the review branch $CURRENT"
}

diffPatches() {
  local change=$1
  if [ "$change" = "" ]; then
    die "You must specify a changeset (and optionally, patch numbers) to diff"
  fi

  local patch1=$2
  local patch2=$3
  local changeref=refs/remotes/changes/${change:(-2)}/$change

  if [ "$patch1" != "" ] && [ "$patch2" != "" ]; then
    local patchref1=$changeref/$patch1
    local patchref2=$changeref/$patch2
  else
    local patchref1=$($GIT rev-parse --symbolic-full-name --all | grep $changeref | sort --reverse | head -n2 | tail -n1)
    local patchref2=$($GIT rev-parse --symbolic-full-name --all | grep $changeref | sort --reverse | head -n1)
    if [ "$patchref1" = "$patchref2" ]; then
      die "Only one patchset--nothing to diff!"
    fi
  fi

  $GIT diff --src-prefix=$patchref1: --dst-prefix=$patchref2: $patchref1 $patchref2
}

rebaseReview() {
  abort_on_bad_repo_state

  local change=$1
  if [ -z "$change" ]; then
    if is_review_branch $CURRENT; then
      local change=${CURRENT:1}
      if [ $run = true ]; then
        good "Using change number $change from branch name"
      fi
    else
      die "Please provide a change number to rebase (see help for more info)"
    fi
  fi

  if ! is_review_branch $CURRENT; then
    # if not already on a review branch, fetch and check it out
    startReview $change
  fi

  # try to push this patch along
  pushReview $change

  # reset if we weren't already on a review branch
  if is_review_branch $CURRENT; then
    resetReview
  fi
}

updateReview() {
  if ! is_review_branch $CURRENT; then
    warn "$CURRENT is not a review branch"
    printUsage
    exit 2
  fi

  abort_on_bad_repo_state

  local change=${CURRENT:1}
  resetReview
  startReview $change
}

abort_on_bad_repo_state() {
  if ! no_changes; then
    die "You have local changes. Please do something with them before using $this"
  fi

  $GIT svn info >/dev/null 2>/dev/null &&
    die "$this does not support git-svn repositories."
}

while true; do
  arg=$1
  shift
  test -z "$arg" && break;

  case $arg
  in
    -e | --explain | --dry-run)
      echo "$this: using explain-only mode"
      explain=true
      verbose=true
      run=false
      ;;
    -v | --verbose)
      verbose=true
      ;;
    -q | --quiet)
      verbose=false
      ;;
    -h | --help)
      printUsage
      exit
      ;;
    start)
      startReview $1
      exit
      ;;
    reset)
      resetReview $@
      exit
      ;;
    push)
      pushReview $1
      exit
      ;;
    diff)
      diffPatches $1 $2 $3
      exit
      ;;
    rebase)
      rebaseReview $1
      exit
      ;;
    update)
      updateReview
      exit
      ;;
    *)
      if is_integer $arg; then
        startReview $arg
        exit
      else
        warn "$this: unrecognized option or subcommand $arg"
        printUsage
        exit 2
      fi
      ;;
  esac
done

# no subcommand given
printShortUsage
exit 2
