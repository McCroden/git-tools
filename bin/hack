#!/bin/bash

CURRENT=$(git symbolic-ref -q HEAD || git rev-parse HEAD)
CURRENT=${CURRENT#refs/heads/}

# default settings
explain=false
verbose=true
run=true

printUsage() {
  echo "usage: $0 [options]"
  echo
  echo "  -h  --help                  Show this message"
  echo "  -v  --verbose               Show all commands before running them (default: on)"
  echo "  -q  --quiet                 Don't display commands before running them (default: off)"
  echo "  -e  --explain  --dry-run    Don't actually run commands (default: off)"
  echo
}

for arg in "$@"; do
  case $arg
  in
    -e | --explain | --dry-run)
      explain=true
      verbose=true
      run=false
      ;;
    -v | --verbose)
      verbose=true
      ;;
    -q | --quiet)
      verbose=false
      ;;
    -h | --help)
      printUsage
      exit
      ;;
    *)
      echo "$0: unrecognized parameter '$arg'"
      printUsage
      exit 1
      ;;
  esac
done

# colors
RED="\033[0;31m"
YELLOW="\033[1;33m"
GREEN="\033[0;32m"
NO_COLOR="\033[0m"

die() {
  echo -e "${RED}${@}${NO_COLOR}"
  exit 1
}

warn() {
  echo -e "${YELLOW}${@}${NO_COLOR}"
}

good() {
  echo -e "${GREEN}${@}${NO_COLOR}"
}

#git stuff
GIT=`which git`

git() {
  if [ "$verbose" = true ]; then
    echo -e "+ ${GREEN}git $@${NO_COLOR}"
  fi

  if [ "$run" = true ]; then
    eval "$GIT $@"
  fi
}

no_changes () {
	$GIT diff-index --quiet --cached HEAD -- &&
	$GIT diff-files --quiet
}

check_stash() {
  if [ "$stashed" = true ]; then
    warn "Your stashed changes were not applied because an error occurred. Don't panic. They are not lost. Look for them in \"git stash list\"."
  fi
}

# initial state
stashed=false

if [ "$explain" = true ]; then
  echo "These are the commands that would be run:"
fi

if no_changes; then
  stashed=false
else
  git stash ||
    die "Could not stash your local changes. Something must be really wrong."
  stashed=true

  trap 'check_stash' EXIT
fi

REMOTE=`$GIT config branch.$CURRENT.remote`

if [ -z "$REMOTE" ]; then
  REMOTE=origin
fi

TRACK=`$GIT config branch.$CURRENT.merge`

if [ -z "$TRACK" ]; then
  TRACK=refs/heads/master
fi

TRACK_BRANCH=${TRACK#refs/heads/}

if [ "$CURRENT" != "$TRACK_BRANCH" ]; then
  git checkout $TRACK_BRANCH ||
    die "Could not switch to $TRACK_BRANCH. Nothing has been changed yet."
fi

$GIT svn info >/dev/null 2>/dev/null
if [ $? = 0 ]; then
  TYPE="git-svn"
else
  TYPE="git"
fi

if [ "$TYPE" = "git-svn" ]; then
  git svn rebase ||
    die "Could not complete the rebase from the upstream Subversion server."
else
  git fetch $REMOTE ||
    die "Could not fetch updates from $REMOTE. Check your network connection."
  git rebase $REMOTE/$TRACK_BRANCH ||
    die "Could not rebase against $REMOTE/$TRACK_BRANCH. You may need to resolve conflicts."
fi

if [ "$CURRENT" != "$TRACK_BRANCH" ]; then
  git checkout $CURRENT ||
    die "Could not switch back to $CURRENT."
  git rebase $TRACK_BRANCH ||
    die "Could not rebase against $TRACK_BRANCH. You may need to resolve conflicts."
fi

if [ "$stashed" = true ]; then
  git stash apply ||
    die "Could not apply your stashed changes over the updates."
  stashed=false
fi

if [ "$run" = true ]; then
  good "Successfully updated `basename $PWD`"
fi
