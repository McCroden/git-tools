#!/bin/bash

CURRENT=$(git symbolic-ref -q HEAD || git rev-parse HEAD)
CURRENT=${CURRENT#refs/heads/}
gitdir=$(git rev-parse --git-dir)

# default settings
explain=false
verbose=true
run=true
branch=$CURRENT

printUsage() {
  echo "usage: $0 [options] [BRANCH]"
  echo
  echo "  -h  --help                  Show this message"
  echo "  -v  --verbose               Show all commands before running them (default: on)"
  echo "  -q  --quiet                 Don't display commands before running them (default: off)"
  echo "  -e  --explain  --dry-run    Don't actually run commands (default: off)"
  echo
  echo "  If BRANCH is given then that branch will be updated and switched to instead of the"
  echo "  current branch."
  echo
}

for arg in "$@"; do
  case $arg
  in
    -e | --explain | --dry-run)
      explain=true
      verbose=true
      run=false
      ;;
    -v | --verbose)
      verbose=true
      ;;
    -q | --quiet)
      verbose=false
      ;;
    -h | --help)
      printUsage
      exit
      ;;
    -*)
      echo "$0: unrecognized parameter '$arg'"
      printUsage
      exit 1
      ;;
    *)
      branch=$arg
      ;;
  esac
done

# colors
RED="\033[0;31m"
YELLOW="\033[1;33m"
GREEN="\033[0;32m"
NO_COLOR="\033[0m"

die() {
  echo -e "${RED}${@}${NO_COLOR}"
  exit 1
}

warn() {
  echo -e "${YELLOW}${@}${NO_COLOR}"
}

good() {
  echo -e "${GREEN}${@}${NO_COLOR}"
}

#git stuff
GIT=`which git`

git() {
  if [ "$verbose" = true ]; then
    echo -e "+ ${GREEN}git $@${NO_COLOR}"
  fi

  if [ "$run" = true ]; then
    eval "$GIT $@"
  fi
}

no_changes () {
  $GIT diff-index --quiet --cached HEAD -- &&
  $GIT diff-files --quiet
}

check_stash() {
  if [ "$stashed" = true ]; then
    warn "Your stashed changes were not applied because an error occurred. Don't panic. They are not lost. Look for them in \"git stash list\"."
  fi
}

switch_to_tracking() {
  if [[ -z "$TRACK" && "$CURRENT" != "$TRACK_BRANCH" ]]; then
    switch_to_branch $TRACK_BRANCH
  fi
}

switch_to_branch() {
  local current
  current=$($GIT symbolic-ref -q HEAD || $GIT rev-parse HEAD)
  current=${current#refs/heads/}

  if [[ $current != $1 ]]; then
    git checkout $1 ||
      die "Could not switch to $1."
  fi
}

are_same_ref() {
  lhs=`$GIT rev-parse $1`
  rhs=`$GIT rev-parse $2`

  if [[ $lhs == $rhs ]]; then
    return 0
  else
    return 1
  fi
}

different_refs() {
  if are_same_ref $1 $2; then
    return 1
  else
    return 0
  fi
}

# initial state
stashed=false

if [ "$explain" = true ]; then
  echo "These are the commands that would be run:"
fi

if no_changes; then
  stashed=false
else
  git stash ||
    die "Could not stash your local changes. Something must be really wrong."
  stashed=true

  trap 'check_stash' EXIT
fi

REMOTE=`$GIT config branch.$branch.remote`

if [ -z "$REMOTE" ]; then
  REMOTE=origin
fi

TRACK=`$GIT config branch.$branch.merge`

if [ -z "$TRACK" ]; then
  # if we're not explicitly tracking something, rebase against master
  TRACK_BRANCH=master
else
  TRACK_BRANCH=${TRACK#refs/heads/}
fi

if [ -d "$gitdir/svn" ]; then
  TYPE="git-svn"
else
  TYPE="git"
fi

if [ "$TYPE" = "git-svn" ]; then
  switch_to_tracking

  git svn rebase ||
    die "Could not complete the rebase from the upstream Subversion server."
else
  git fetch $REMOTE ||
    die "Could not fetch updates from $REMOTE. Check your network connection."

  if different_refs $TRACK_BRANCH $REMOTE/$TRACK_BRANCH; then
    switch_to_tracking

    if different_refs HEAD $REMOTE/$TRACK_BRANCH; then
      git rebase $REMOTE/$TRACK_BRANCH ||
        die "Could not rebase against $REMOTE/$TRACK_BRANCH. You may need to resolve conflicts."
    fi
  fi
fi

if [[ -z "$TRACK" && "$branch" != "$TRACK_BRANCH" ]]; then
  switch_to_branch $branch
  git rebase $TRACK_BRANCH ||
    die "Could not rebase against $TRACK_BRANCH. You may need to resolve conflicts."
fi

if [ "$stashed" = true ]; then
  git stash apply ||
    die "Could not apply your stashed changes over the updates."
  stashed=false
fi

if [ "$run" = true ]; then
  good "Successfully updated `basename $PWD`"
fi
